<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>27번 도구 – CSV 업로드 · 표준 컬럼 매핑 · X 자동검증</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121924; --panel2:#0f1620; --txt:#e9eef6; --muted:#9fb0c3;
      --line:#243044; --ok:#2bd576; --bad:#ff4d4d; --warn:#ffcc00; --btn:#1b2636;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--txt); }
    header{ position:sticky; top:0; z-index:50; background:linear-gradient(180deg, rgba(11,15,20,.98), rgba(11,15,20,.86)); border-bottom:1px solid var(--line); }
    .wrap{ max-width:1200px; margin:0 auto; padding:12px; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .badge{ padding:6px 10px; border:1px solid var(--line); border-radius:999px; background:rgba(18,25,36,.7); font-size:12px; color:var(--muted); }
    .btn{
      background:var(--btn); color:var(--txt); border:1px solid var(--line);
      padding:10px 12px; border-radius:10px; cursor:pointer; font-size:13px;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{ border-color:#2a79ff; }
    .btn.danger{ border-color:#ff4d4d; }
    .btn.ok{ border-color:#2bd576; }
    .btn.small{ padding:6px 10px; border-radius:8px; font-size:12px; }
    input[type="file"]{ display:none; }
    .hint{ font-size:12px; color:var(--muted); margin-top:6px; }
    .panel{ background:rgba(18,25,36,.6); border:1px solid var(--line); border-radius:14px; padding:10px; }
    .kpis{ display:flex; gap:8px; flex-wrap:wrap; }
    .kpi{ padding:6px 10px; border-radius:999px; background:rgba(15,22,32,.8); border:1px solid var(--line); font-size:12px; color:var(--muted); }
    main .wrap{ padding-top:8px; }
    .tableWrap{
      border:1px solid var(--line); border-radius:14px; overflow:hidden;
      background:rgba(18,25,36,.45);
    }
    table{ width:100%; border-collapse:separate; border-spacing:0; table-layout:fixed; }
    thead th{
      position:sticky; top:64px; z-index:10;
      background:rgba(15,22,32,.98); color:var(--muted);
      border-bottom:1px solid var(--line); padding:10px 8px; font-size:12px; text-align:left;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid rgba(36,48,68,.65);
      padding:8px; vertical-align:top; font-size:13px;
      word-break:break-word; overflow-wrap:anywhere;
    }
    tbody tr:hover td{ background:rgba(15,22,32,.55); }
    .colTiny{ width:64px; }
    .colPub{ width:110px; }
    .colISBN{ width:150px; }
    .colPrice{ width:90px; }
    .colCur{ width:90px; }
    .colDate{ width:110px; }
    .colPages{ width:80px; }
    .colAnchor{ width:220px; color:var(--muted); font-size:11px; }
    .pill{ display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid var(--line); background:rgba(15,22,32,.7); font-size:12px; color:var(--muted); }
    .markX{ color:var(--bad); font-weight:700; }
    .markOK{ color:var(--ok); font-weight:700; }
    .xbtn{
      display:inline-flex; align-items:center; justify-content:center;
      width:30px; height:24px; border-radius:8px;
      border:1px solid var(--line); background:rgba(15,22,32,.8); cursor:pointer;
      font-weight:800; user-select:none;
    }
    .xbtn.on{ border-color:var(--bad); background:rgba(255,77,77,.12); color:var(--bad); }
    .xbtn.off{ border-color:rgba(43,213,118,.4); background:rgba(43,213,118,.08); color:var(--ok); }
    .footerBar{
      position:fixed; left:0; right:0; bottom:0; z-index:60;
      background:rgba(11,15,20,.95); border-top:1px solid var(--line);
    }
    details{ background:rgba(18,25,36,.55); border:1px solid var(--line); border-radius:14px; padding:10px; }
    details summary{ cursor:pointer; color:var(--muted); font-size:13px; }
    pre{ margin:8px 0 0; max-height:240px; overflow:auto; background:rgba(15,22,32,.7); padding:10px; border-radius:12px; border:1px solid var(--line); font-size:12px; }
    .modalBack{
      position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:80;
      padding:14px;
    }
    .modal{
      width:min(980px, 100%); max-height:86vh; overflow:auto;
      background:rgba(18,25,36,.98); border:1px solid var(--line); border-radius:16px; padding:12px;
    }
    .modal h3{ margin:0 0 10px; font-size:14px; color:var(--txt); }
    .list{ display:flex; flex-direction:column; gap:8px; }
    .item{ border:1px solid var(--line); border-radius:12px; padding:10px; background:rgba(15,22,32,.7); }
    .itemTop{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .itemMeta{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .reason{ color:var(--muted); font-size:12px; margin-top:6px; }
    .mono{ font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .right{ margin-left:auto; }
    .spacer{ height:110px; }
    @media (max-width:720px){
      thead th{ top:118px; }
      header .row{ align-items:flex-start; }
    }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="row">
      <div class="panel" style="flex:1; min-width:260px;">
        <div style="font-weight:700; font-size:14px;">27번 도구 – CSV 업로드 · 표준 컬럼 매핑 · X 자동검증</div>
        <div class="hint">FREEZE: 필드/순서/라벨 고정(값만 공란) · ANCHOR: (file|row|id) · 원본에 없는 값 생성 금지</div>
      </div>

      <label class="btn primary" for="fileInput">업로드(추가)</label>
      <input id="fileInput" type="file" accept=".csv,text/csv" multiple />

      <button class="btn danger" id="btnResetDB">DB 초기화</button>
      <button class="btn" id="btnClearLog">로그 초기화</button>

      <button class="btn ok" id="btnShowX">X 후보 보기</button>
      <button class="btn" id="btnApplyAllX">X 후보 전체 ON</button>
      <button class="btn" id="btnClearAllX">X 전체 OFF</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <div class="kpis">
        <span class="kpi">DB: <b id="kpiRows">0</b> rows</span>
        <span class="kpi">AUTO X: <b id="kpiAutoX">0</b></span>
        <span class="kpi">USER X: <b id="kpiUserX">0</b></span>
        <span class="kpi">Last: <b id="kpiLast">-</b></span>
        <span class="kpi">정렬: Pub Date ↑ (이 도구 전용)</span>
        <span class="kpi">저장: localStorage 자동</span>
      </div>
      <button class="btn small right" id="btnResort">정렬 재적용</button>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div class="tableWrap">
      <table id="tbl">
        <thead>
          <tr id="hdr"></tr>
        </thead>
        <tbody id="body"></tbody>
      </table>
    </div>
    <div class="spacer"></div>
  </div>
</main>

<div class="footerBar">
  <div class="wrap">
    <details id="logBox" open>
      <summary>로그(하단 고정 · 기본 접힘 가능)</summary>
      <pre id="log"></pre>
    </details>
  </div>
</div>

<div class="modalBack" id="modalBack">
  <div class="modal">
    <div class="row" style="margin-bottom:10px;">
      <h3 style="flex:1;">X 후보 리스트(도구가 자동 산출)</h3>
      <button class="btn" id="btnCloseModal">닫기</button>
    </div>
    <div class="hint" style="margin-bottom:10px;">
      사용자는 “확인 → 전체 ON/전체 OFF”만 하면 됨. (개별 해제도 가능)
    </div>
    <div class="list" id="xList"></div>
  </div>
</div>

<script>
/** ===========================
 *  LOCK_SCHEMA (FREEZE 상수)
 *  =========================== */
const LOCK_STANDARD_COLS = [
  "Publisher","Title","Sub Title","KOR_TITLE","KOR_SUBTITLE","ISBN","Price","Currency","Pub Date","Pages","_ANCHOR(file|row|id)"
];

const LOCK_COL_WIDTH = {
  "Publisher":"colPub",
  "ISBN":"colISBN",
  "Price":"colPrice",
  "Currency":"colCur",
  "Pub Date":"colDate",
  "Pages":"colPages",
  "_ANCHOR(file|row|id)":"colAnchor"
};

const LOCK_X_RULES = [
  { key:"PRICE_ZERO",  desc:"Price = 0 또는 비어있음" },
  { key:"DATE_BAD",    desc:"날짜 형식 깨짐/해석 불가" },
  { key:"ISBN_BAD",    desc:"ISBN 13자리 불일치" },
  { key:"CURR_EMPTY",  desc:"Currency 비어있음(필수)" },
  { key:"PRICE_BAD",   desc:"Price 숫자 해석 불가" },
  { key:"PAGES_BAD",   desc:"Pages 숫자 해석 불가(값이 있는데 숫자 아님)" }
];

// 원본 컬럼 목록(발행사별) + 매핑표(원본→표준) : 코드 상수로 고정
const LOCK_PUBLISHER_MAP = [
  {
    publisher: "Elsevier",
    matchFile: (name)=> /\(elsevier\)/i.test(name) || /elsevier/i.test(name),
    mapping: {
      "Title": "Title",
      "Sub Title": "",
      "KOR_TITLE": "",
      "KOR_SUBTITLE": "",
      "ISBN": "ISBN",
      "Price": "List Price (USD)",
      "Currency": "__CONST_USD__",
      "Pub Date": "Pub date",
      "Pages": "No of Pages"
    }
  },
  {
    publisher: "Springer",
    matchFile: (name)=> /^springer-/i.test(name) || /springer/i.test(name),
    mapping: {
      "Title": "Title",
      "Sub Title": "Sub Title",
      "KOR_TITLE": "",
      "KOR_SUBTITLE": "",
      "ISBN": "ISBN",
      "Price": "Price EUR",
      "Currency": "__CONST_EUR__",
      "Pub Date": "Actual Publishing Date",
      "Pages": "No of Arabic Pages"
    }
  },
  {
    publisher: "Wiley",
    matchFile: (name)=> /wiley/i.test(name),
    mapping: {
      "Title": "Title",
      "Sub Title": "",
      "KOR_TITLE": "",
      "KOR_SUBTITLE": "",
      "ISBN": "ISBN13",
      "Price": "US$",
      "Currency": "__CONST_USD__",
      "Pub Date": "Pub Date",
      "Pages": "Pages"
    }
  }
];

/** ===========================
 *  상태 저장
 *  =========================== */
const LS_KEY = "wic27_db_v3";
const LS_X_USER = "wic27_x_user_v3";
const LS_LOG = "wic27_log_v3";

let DB = []; // rows
let userX = loadJSON(LS_X_USER, {});
let logLines = loadJSON(LS_LOG, []);

// ✅ 행 섞임 0% 핵심: rowId(=anchorKey) 중복 방지용 Set
let ROWKEY_SET = new Set();

function loadJSON(key, fallback){
  try{
    const raw = localStorage.getItem(key);
    if(!raw) return fallback;
    return JSON.parse(raw);
  }catch(e){ return fallback; }
}
function saveJSON(key, val){
  localStorage.setItem(key, JSON.stringify(val));
}

/** ===========================
 *  유틸
 *  =========================== */
function djb2(str){
  let h = 5381;
  for(let i=0;i<str.length;i++){
    h = ((h<<5)+h) + str.charCodeAt(i);
    h = h >>> 0;
  }
  return ("00000000" + h.toString(16)).slice(-8);
}

function parseCSV(text){
  const rows = [];
  let i=0, cur="", inQ=false;
  const row=[];
  function pushCell(){ row.push(cur); cur=""; }
  function pushRow(){
    if(row.length===1 && row[0].trim()===""){ row.length=0; return; }
    rows.push(row.slice());
    row.length=0;
  }
  while(i<text.length){
    const ch = text[i];
    if(inQ){
      if(ch === '"'){
        if(text[i+1] === '"'){ cur+='"'; i+=2; continue; }
        inQ=false; i++; continue;
      }
      cur += ch; i++; continue;
    }else{
      if(ch === '"'){ inQ=true; i++; continue; }
      if(ch === ','){ pushCell(); i++; continue; }
      if(ch === '\n'){ pushCell(); pushRow(); i++; continue; }
      if(ch === '\r'){ i++; continue; }
      cur += ch; i++; continue;
    }
  }
  pushCell(); pushRow();
  return rows;
}

/** ===========================
 *  데이터 정규화
 *  =========================== */
function normBlank(v){
  if(v==null) return "";
  return String(v).trim();
}
function stripMoney(s){
  s = normBlank(s);
  if(!s) return "";
  s = s.replace(/[,\s]/g,"");
  s = s.replace(/^\$/,"");
  return s;
}
function toNumberOrBlank(s){
  s = stripMoney(s);
  if(!s) return "";
  const n = Number(s);
  if(Number.isFinite(n)) return String(n);
  return "__BAD__";
}
function sciToIntStr(s){
  s = normBlank(s);
  if(!s) return "";
  const m = s.match(/^([0-9]+(?:\.[0-9]+)?)E\+([0-9]+)$/i);
  if(!m) return s;
  const base = m[1];
  const exp = parseInt(m[2],10);
  const parts = base.split(".");
  const intPart = parts[0];
  const fracPart = (parts[1]||"");
  const digits = (intPart + fracPart).replace(/^0+/,"") || "0";
  const zeros = exp - fracPart.length;
  if(zeros >= 0) return digits + "0".repeat(zeros);
  return s;
}
function normISBN(s){
  s = normBlank(s);
  if(!s) return "";
  if(/E\+/i.test(s)) s = sciToIntStr(s);
  const digits = s.replace(/[^0-9]/g,"");
  if(digits.length===13) return digits;
  if(digits.length===10) return digits;
  return digits || s;
}

const MONTH = {jan:1,feb:2,mar:3,apr:4,may:5,jun:6,jul:7,aug:8,sep:9,oct:10,nov:11,dec:12};
function pad2(n){ return (n<10?("0"+n):String(n)); }
function isValidDate(y,m,d){
  if(y<1900||y>2100) return false;
  if(m<1||m>12) return false;
  const dt = new Date(y, m-1, d);
  return dt.getFullYear()===y && (dt.getMonth()+1)===m && dt.getDate()===d;
}
function normDate(s){
  s = normBlank(s);
  if(!s) return "";
  let m = s.match(/^(\d{4})-(\d{1,2})-(\d{1,2})$/);
  if(m){
    const y=+m[1], mo=+m[2], d=+m[3];
    if(isValidDate(y,mo,d)) return `${y}-${pad2(mo)}-${pad2(d)}`;
    return "__BAD__";
  }
  m = s.match(/^(\d{1,2})-([A-Za-z]{3})-(\d{2}|\d{4})$/);
  if(m){
    const d=+m[1];
    const mo = MONTH[m[2].toLowerCase()];
    let y = +m[3];
    if(!mo) return "__BAD__";
    if(String(m[3]).length===2) y = 2000 + y;
    if(isValidDate(y,mo,d)) return `${y}-${pad2(mo)}-${pad2(d)}`;
    return "__BAD__";
  }
  return "__BAD__";
}
function normPages(s){
  s = normBlank(s);
  if(!s) return "";
  const t = s.replace(/[,\s]/g,"");
  if(/^\d+$/.test(t)) return t;
  return "__BAD__";
}

function detectPublisher(fileName){
  for(const p of LOCK_PUBLISHER_MAP){
    if(p.matchFile(fileName)) return p.publisher;
  }
  const m = fileName.match(/\(([^)]+)\)/);
  if(m) return m[1].trim();
  return "Unknown";
}
function getMappingFor(fileName){
  const pub = detectPublisher(fileName);
  const entry = LOCK_PUBLISHER_MAP.find(x => x.publisher===pub);
  return entry ? entry.mapping : null;
}
function cleanPublisherFromFile(_fileName, detected){
  return detected; // "Elsevier" 같은 깨끗한 표기만 사용
}

/** ===========================
 *  X 자동 후보 산출
 *  =========================== */
function autoXForCell(row, col){
  const v = row[col];
  const blankOK = (v==="" || v==="(빈칸)");
  if(blankOK){
    if(col==="Currency") return {on:true, reason:"CURR_EMPTY: Currency 비어있음(필수)"}; 
    return {on:false, reason:""};
  }
  if(col==="Price"){
    const n = Number(v);
    if(!Number.isFinite(n)) return {on:true, reason:"PRICE_BAD: Price 숫자 해석 불가"};
    if(n===0) return {on:true, reason:"PRICE_ZERO: Price = 0"};
  }
  if(col==="Pub Date"){
    if(v==="__BAD__") return {on:true, reason:"DATE_BAD: 날짜 형식 깨짐"};
  }
  if(col==="ISBN"){
    const digits = v.replace(/[^0-9]/g,"");
    if(!(digits.length===13)) return {on:true, reason:"ISBN_BAD: ISBN 13자리 아님"};
  }
  if(col==="Pages"){
    if(v==="__BAD__") return {on:true, reason:"PAGES_BAD: Pages 숫자 아님"};
  }
  if(col==="Currency"){
    if(!v) return {on:true, reason:"CURR_EMPTY: Currency 비어있음(필수)"};
  }
  return {on:false, reason:""};
}
function anchorKey(row){ return row.__anchorKey; }

/** ===========================
 *  로그
 *  =========================== */
function log(event, payload){
  const now = new Date();
  const ts = now.toISOString().replace("T"," ").slice(0,19);
  const line = `[${ts}] ${event} :: ${JSON.stringify(payload)}`;
  logLines.push(line);
  if(logLines.length>600) logLines = logLines.slice(-600);
  saveJSON(LS_LOG, logLines);
  renderLog();
}
function renderLog(){
  document.getElementById("log").textContent = logLines.join("\n");
}

/** ===========================
 *  렌더
 *  =========================== */
const hdrEl = document.getElementById("hdr");
const bodyEl = document.getElementById("body");

function renderHeader(){
  hdrEl.innerHTML = "";
  for(const col of LOCK_STANDARD_COLS){
    const th = document.createElement("th");
    th.textContent = col;
    const cls = LOCK_COL_WIDTH[col] || "";
    if(cls) th.classList.add(cls);
    hdrEl.appendChild(th);
  }
}
function fmtCell(v){
  if(v==="") return "(빈칸)";
  if(v==="__BAD__") return "(형식오류)";
  return v;
}
function render(){
  renderHeader();
  bodyEl.innerHTML = "";

  document.getElementById("kpiRows").textContent = String(DB.length);
  document.getElementById("kpiAutoX").textContent = String(countAutoX());
  document.getElementById("kpiUserX").textContent = String(countUserX());

  const frag = document.createDocumentFragment();

  for(const row of DB){
    const tr = document.createElement("tr");
    // ✅ 행 섞임 0% 증거: DOM에도 고정 키를 박아둠(디버그 용)
    tr.dataset.rowid = row.__anchorKey;

    for(const col of LOCK_STANDARD_COLS){
      const td = document.createElement("td");

      if(col === "_ANCHOR(file|row|id)"){
        td.classList.add("colAnchor","mono");
        td.textContent = row._ANCHOR;
        tr.appendChild(td);
        continue;
      }

      const btn = document.createElement("div");
      btn.className = "xbtn";
      const st = getXState(row, col);
      btn.textContent = "X";
      btn.classList.add(st.on ? "on":"off");
      btn.title = st.on ? (st.reason || "X") : "PASS";
      btn.addEventListener("click", ()=>{ toggleUserX(row, col); });

      const val = document.createElement("div");
      val.textContent = fmtCell(row[col]);
      if(row[col]==="__BAD__") val.style.color = "var(--warn)";
      if(fmtCell(row[col])==="(빈칸)") val.style.color = "var(--muted)";

      td.appendChild(btn);
      td.appendChild(val);

      const cls = LOCK_COL_WIDTH[col] || "";
      if(cls) td.classList.add(cls);

      tr.appendChild(td);
    }
    frag.appendChild(tr);
  }

  bodyEl.appendChild(frag);
  saveJSON(LS_KEY, DB);
}

function countAutoX(){
  let c=0;
  for(const r of DB){
    for(const col of LOCK_STANDARD_COLS){
      if(col==="_ANCHOR(file|row|id)") continue;
      const ax = autoXForCell(r,col);
      if(ax.on) c++;
    }
  }
  return c;
}
function countUserX(){
  let c=0;
  for(const k in userX){
    for(const col in userX[k]){
      if(userX[k][col]) c++;
    }
  }
  return c;
}
function getXState(row, col){
  const k = anchorKey(row);
  const ux = !!(userX[k] && userX[k][col]);
  if(ux) return {on:true, auto:false, reason:"USER_X"};
  const ax = autoXForCell(row,col);
  return {on:ax.on, auto:true, reason:ax.reason};
}
function toggleUserX(row, col){
  const k = anchorKey(row);
  userX[k] = userX[k] || {};
  const now = !userX[k][col];
  userX[k][col] = now;
  saveJSON(LS_X_USER, userX);
  log("X 토글", { anchor: row.__anchor, col, on: now });
  render();
}

/** ===========================
 *  X 리스트(자동) + 전체 버튼
 *  =========================== */
function buildXList(){
  const items = [];
  for(const r of DB){
    for(const col of LOCK_STANDARD_COLS){
      if(col==="_ANCHOR(file|row|id)") continue;
      const st = getXState(r,col);
      if(st.auto && st.on){
        items.push({
          anchor: r.__anchor,
          anchorStr: r._ANCHOR,
          col,
          value: fmtCell(r[col]),
          reason: st.reason
        });
      }
    }
  }
  return items;
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
}
function renderXModal(){
  const listEl = document.getElementById("xList");
  listEl.innerHTML = "";
  const items = buildXList();
  if(items.length===0){
    const d=document.createElement("div");
    d.className="item";
    d.textContent="X 후보가 없음";
    listEl.appendChild(d);
    return;
  }
  items.forEach((it, idx)=>{
    const box = document.createElement("div");
    box.className = "item";

    const top = document.createElement("div");
    top.className = "itemTop";

    const meta = document.createElement("div");
    meta.className = "itemMeta";
    meta.innerHTML = `
      <span class="pill"><b>#${idx+1}</b></span>
      <span class="pill mono">${it.anchorStr}</span>
      <span class="pill"><b>${it.col}</b></span>
      <span class="pill">${escapeHtml(it.value)}</span>
    `;

    const act = document.createElement("button");
    act.className = "btn small";
    act.textContent = "이 항목만 USER_X로 고정";
    act.addEventListener("click", ()=>{
      const row = DB.find(r => r._ANCHOR === it.anchorStr);
      if(row){
        const k = anchorKey(row);
        userX[k] = userX[k] || {};
        userX[k][it.col] = true;
        saveJSON(LS_X_USER, userX);
        log("X 고정(USER_X)", {anchor: it.anchor, col: it.col, on:true});
        render();
        renderXModal();
      }
    });

    top.appendChild(meta);
    top.appendChild(act);

    const reason = document.createElement("div");
    reason.className="reason";
    reason.textContent = it.reason;

    box.appendChild(top);
    box.appendChild(reason);
    listEl.appendChild(box);
  });
}
function applyAllAutoXToUserX(){
  const items = buildXList();
  items.forEach(it=>{
    const row = DB.find(r => r._ANCHOR === it.anchorStr);
    if(!row) return;
    const k = anchorKey(row);
    userX[k] = userX[k] || {};
    userX[k][it.col] = true;
  });
  saveJSON(LS_X_USER, userX);
  log("X 후보 전체 ON", {count: items.length});
  render();
}
function clearAllUserX(){
  userX = {};
  saveJSON(LS_X_USER, userX);
  log("X 전체 OFF", {});
  render();
}

/** ===========================
 *  업로드(추가)
 *  =========================== */
async function handleFiles(files){
  for(const f of files){
    await readAndAppendFile(f);
  }
  sortDB();
  render();
}
function readFileAsText(file){
  return new Promise((res, rej)=>{
    const fr = new FileReader();
    fr.onload = ()=> res(fr.result);
    fr.onerror = ()=> rej(fr.error);
    fr.readAsText(file);
  });
}

async function readAndAppendFile(file){
  const name = file.name;
  const publisher = cleanPublisherFromFile(name, detectPublisher(name));
  const mapping = getMappingFor(name);

  const text = await readFileAsText(file);
  const rows = parseCSV(text);
  if(rows.length<2){
    log("업로드(추가) 실패", {file:name, reason:"no rows"});
    return;
  }
  const headers = rows[0].map(h=>normBlank(h));
  log("업로드(추가) 시작", {file:name, publisher, headers});

  const mapLog = {};
  if(mapping){
    for(const std of Object.keys(mapping)){
      mapLog[std] = mapping[std] || "";
    }
  }
  log("매핑표(원본→표준) 확정", {file:name, mapping: mapLog});

  let appended = 0;
  for(let i=1;i<rows.length;i++){
    const rawRow = rows[i];
    if(rawRow.every(c=>normBlank(c)==="")) continue;

    const rec = makeStandardRow({
      fileName:name,
      publisher,
      headers,
      rawRow,
      rowIndex:i, // ✅ 원본행번호 (CSV body의 i) = 고정 키의 일부
      mapping
    });

    // ✅ 행 섞임 0% 핵심 1줄: rowId 중복이면 추가 금지
    if(ROWKEY_SET.has(rec.__anchorKey)) continue;

    DB.push(rec);
    ROWKEY_SET.add(rec.__anchorKey);
    appended++;
  }

  log("업로드(추가) 완료", {file:name, appended, total:DB.length});
  document.getElementById("kpiLast").textContent = name;
}

function getCell(headers, rawRow, colName){
  const idx = headers.findIndex(h => h.trim() === colName.trim());
  if(idx<0) return "";
  return normBlank(rawRow[idx] ?? "");
}

// ✅ 행 섞임 0% 핵심: anchor.id는 file+rowIndex만으로 계산(Title/ISBN 영향 제거)
function makeAnchor(fileName, rowIndex){
  const stable = `${fileName}|${rowIndex}`;      // ← 이 1줄이 “절대 고정키”
  const id = djb2(stable);
  const anchor = { file:fileName, rowIndex: rowIndex, id };
  const anchorStr = `${fileName} | ${rowIndex} | ${id}`;
  const anchorKey = `${fileName}|${rowIndex}|${id}`; // ← 렌더/저장/토글 모두 이 키만 사용
  return {anchor, anchorStr, anchorKey};
}

function makeStandardRow({fileName,publisher,headers,rawRow,rowIndex,mapping}){
  const out = {};
  out["Publisher"] = publisher;

  function mapStd(std){
    const src = mapping ? mapping[std] : "";
    if(!src) return "";
    if(src === "__CONST_USD__") return "USD";
    if(src === "__CONST_EUR__") return "EUR";
    if(src === "__BLANK__") return "";
    return getCell(headers, rawRow, src);
  }

  out["Title"] = mapStd("Title");
  out["Sub Title"] = mapStd("Sub Title");
  out["KOR_TITLE"] = mapStd("KOR_TITLE");
  out["KOR_SUBTITLE"] = mapStd("KOR_SUBTITLE");

  out["ISBN"] = normISBN(mapStd("ISBN"));

  const priceRaw = mapStd("Price");
  const priceNorm = toNumberOrBlank(priceRaw);
  out["Price"] = (priceNorm==="__BAD__") ? "__BAD__" : priceNorm;

  out["Currency"] = normBlank(mapStd("Currency"));

  out["Pub Date"] = normDate(mapStd("Pub Date"));

  out["Pages"] = normPages(mapStd("Pages"));

  const anc = makeAnchor(fileName, rowIndex);
  out._ANCHOR = anc.anchorStr;
  out.__anchor = anc.anchor;
  out.__anchorKey = anc.anchorKey;

  return out;
}

/** ===========================
 *  정렬 (Pub Date ↑)
 *  =========================== */
function sortDB(){
  DB.sort((a,b)=>{
    const da = (a["Pub Date"] && a["Pub Date"]!=="__BAD__") ? a["Pub Date"] : "9999-99-99";
    const db = (b["Pub Date"] && b["Pub Date"]!=="__BAD__") ? b["Pub Date"] : "9999-99-99";
    if(da<db) return -1;
    if(da>db) return 1;
    return a.__anchorKey < b.__anchorKey ? -1 : 1;
  });
}

/** ===========================
 *  초기 로드
 *  =========================== */
function rebuildRowKeySet(){
  ROWKEY_SET = new Set();
  for(const r of DB){
    if(r && r.__anchorKey) ROWKEY_SET.add(r.__anchorKey);
  }
}
function loadDB(){
  const saved = loadJSON(LS_KEY, []);
  if(Array.isArray(saved) && saved.length){
    DB = saved;
  }else{
    DB = [];
  }
  rebuildRowKeySet();
}
loadDB();
renderLog();
render();

/** ===========================
 *  이벤트
 *  =========================== */
document.getElementById("fileInput").addEventListener("change", async (e)=>{
  const files = Array.from(e.target.files || []);
  if(!files.length) return;
  await handleFiles(files);
  e.target.value = "";
});

document.getElementById("btnResetDB").addEventListener("click", ()=>{
  DB = [];
  saveJSON(LS_KEY, DB);
  userX = {};
  saveJSON(LS_X_USER, userX);
  log("DB 초기화", {});
  rebuildRowKeySet();
  render();
});

document.getElementById("btnClearLog").addEventListener("click", ()=>{
  logLines = [];
  saveJSON(LS_LOG, logLines);
  renderLog();
});

document.getElementById("btnResort").addEventListener("click", ()=>{
  sortDB();
  log("정렬 재적용", {by:"Pub Date ↑"});
  render();
});

document.getElementById("btnShowX").addEventListener("click", ()=>{
  renderXModal();
  document.getElementById("modalBack").style.display="flex";
});
document.getElementById("btnCloseModal").addEventListener("click", ()=>{
  document.getElementById("modalBack").style.display="none";
});
document.getElementById("modalBack").addEventListener("click", (e)=>{
  if(e.target.id==="modalBack") document.getElementById("modalBack").style.display="none";
});

document.getElementById("btnApplyAllX").addEventListener("click", ()=>{
  applyAllAutoXToUserX();
});
document.getElementById("btnClearAllX").addEventListener("click", ()=>{
  clearAllUserX();
});
</script>
</body>
</html>
