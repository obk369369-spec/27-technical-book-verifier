<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<title>27번 도구 – 엑셀 업로드 · 표준 매핑 · X 자동검증</title>
<style>
body{font-family:Arial;margin:12px}
button{margin:2px 4px;padding:6px 10px}
table{border-collapse:collapse;width:100%;font-size:13px}
th,td{border:1px solid #ccc;padding:4px;text-align:left}
th{background:#f3f3f3}
.xbtn{font-weight:bold;color:#c00;cursor:pointer}
.log{position:fixed;left:0;right:0;bottom:0;height:140px;background:#fff;border-top:2px solid #000;overflow:auto;font-size:12px}
.logHeader{background:#eee;padding:4px;cursor:pointer}
.hidden{display:none}
</style>
</head>
<body>

<h3>27번 도구 – CSV 업로드 · 표준 컬럼 매핑 · X 자동검증</h3>

<input type="file" id="fileInput" accept=".csv" />
<button onclick="loadCSV()">업로드</button>
<button onclick="clearDB()">DB 초기화</button>

<hr/>

<h4>표준 표(작업)</h4>
<table id="stdTable"></table>

<div class="log" id="logBox">
  <div class="logHeader" onclick="toggleLog()">자동 로그 (접기/펼치기)</div>
  <div id="logBody"></div>
</div>

<script>
// ===== FREEZE 상수 =====
const FIELD_ORDER = [
"Publisher","Title","Sub Title","KOR_TITLE","KOR_SUBTITLE",
"ISBN","Price","Currency","Pub Date","Pages"
];

// ===== 상태 =====
let stdRows = [];
let logs = [];

// ===== CSV 로드 =====
function loadCSV(){
  const f=document.getElementById('fileInput').files[0];
  if(!f) return;
  const reader=new FileReader();
  reader.onload=e=>{
    const txt=e.target.result;
    parseCSV(txt,f.name);
  };
  reader.readAsText(f);
}

// ===== CSV 파싱 =====
function parseCSV(txt,filename){
  const lines=txt.split(/\r?\n/).filter(l=>l.trim());
  const headers=lines[0].split(",");
  const pub = filename.split(" ")[0]; // 발행사 자동
  stdRows=[];

  for(let i=1;i<lines.length;i++){
    const cols=lines[i].split(",");
    let row={};
    FIELD_ORDER.forEach(f=>row[f]="");

    row["Publisher"]=pub;

    headers.forEach((h,idx)=>{
      const v=cols[idx]||"";
      if(h.toLowerCase().includes("title")) row["Title"]=v;
      if(h.toLowerCase().includes("isbn")) row["ISBN"]=v;
      if(h.toLowerCase().includes("date")) row["Pub Date"]=v;
      if(h.toLowerCase().includes("price")) row["Price"]=v;
    });

    stdRows.push(row);
  }

  sortByDate();
  autoX();
  render();
}

// ===== 정렬 =====
function sortByDate(){
  stdRows.sort((a,b)=> new Date(a["Pub Date"]) - new Date(b["Pub Date"]));
}

// ===== X 자동 분류 =====
function autoX(){
  stdRows.forEach(r=>{
    r._x={};
    if(r.Price==="0") r._x.Price=true;
    if(r.ISBN && r.ISBN.length<10) r._x.ISBN=true;
  });
}

// ===== 렌더 =====
function render(){
  const t=document.getElementById("stdTable");
  t.innerHTML="";
  let tr=document.createElement("tr");
  FIELD_ORDER.forEach(f=>{
    let th=document.createElement("th");
    th.textContent=f;
    tr.appendChild(th);
  });
  t.appendChild(tr);

  stdRows.forEach((r,ri)=>{
    let tr=document.createElement("tr");
    FIELD_ORDER.forEach(f=>{
      let td=document.createElement("td");
      td.textContent=r[f]||"(빈칸)";
      if(r._x && r._x[f]){
        const x=document.createElement("span");
        x.textContent=" X";
        x.className="xbtn";
        x.onclick=()=>toggleX(ri,f);
        td.appendChild(x);
      }
      tr.appendChild(td);
    });
    t.appendChild(tr);
  });
}

// ===== X 토글 =====
function toggleX(r,f){
  stdRows[r]._x[f]=!stdRows[r]._x[f];
  addLog(`X 토글: ${r} / ${f}`);
  render();
}

// ===== 로그 =====
function addLog(msg){
  logs.push(msg);
  document.getElementById("logBody").innerHTML=logs.join("<br>");
}

function toggleLog(){
  document.getElementById("logBody").classList.toggle("hidden");
}

// ===== DB 초기화 =====
function clearDB(){
  stdRows=[];
  logs=[];
  render();
  document.getElementById("logBody").innerHTML="";
}
</script>

</body>
</html>
