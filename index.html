<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>27번 도구 – 엑셀 업로드 (셀 X 안정화 v1)</title>
  <style>
    :root{
      --bg:#f3f4f6; --panel:#ffffff; --text:#111827; --muted:#6b7280;
      --line:#e5e7eb; --xbg:#fee2e2; --xtext:#991b1b; --xline:#fca5a5;
      --okbg:#dcfce7; --oktext:#166534; --okline:#86efac;
      --pill:#eef2ff;
    }
    html,body{height:100%;}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR",sans-serif;
    }
    .container{max-width:1500px; margin:16px auto; padding:0 12px;}
    .card{
      background:var(--panel); border:1px solid var(--line); border-radius:14px;
      box-shadow:0 1px 2px rgba(0,0,0,.06);
    }
    .header{padding:14px 16px; border-bottom:1px solid var(--line);}
    .header .title{font-weight:900; font-size:16px;}
    .header .desc{color:var(--muted); font-size:13px; margin-top:6px; line-height:1.4;}
    .row{display:grid; grid-template-columns: 1fr 360px; gap:12px;}
    .main{min-width:0;}
    .side{
      min-width:0;
      background:var(--panel);
      border-left:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
    }
    .sideHead{padding:12px 12px; border-bottom:1px solid var(--line); font-weight:800;}
    .sideBody{padding:10px 12px; max-height:520px; overflow:auto; font-size:12px; color:#111827; white-space:pre-wrap;}
    .sideFoot{padding:10px 12px; border-top:1px solid var(--line); display:flex; gap:8px; flex-wrap:wrap;}
    .btn{
      border:1px solid var(--line); background:#fff; color:#111827;
      padding:10px 12px; border-radius:12px; font-weight:800; cursor:pointer;
    }
    .btn:hover{filter:brightness(.98);}
    .btn.danger{border-color:#fecaca; background:#fff1f2; color:#9f1239;}
    .btn.ok{border-color:var(--okline); background:var(--okbg); color:var(--oktext);}
    .toolbar{
      padding:12px 16px; border-bottom:1px solid var(--line);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .pill{
      background:var(--pill); border:1px solid #c7d2fe; color:#1e3a8a;
      padding:6px 10px; border-radius:999px; font-weight:800; font-size:12px;
    }
    .stat{font-size:12px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap;}
    .stat b{color:#111827;}
    .file{
      border:1px dashed #cbd5e1; background:#f8fafc; padding:10px 12px; border-radius:12px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    input[type="file"]{font-weight:700;}
    .hint{font-size:12px; color:var(--muted); line-height:1.45;}
    .tableWrap{overflow:auto; padding:10px 12px;}
    table{width:100%; border-collapse:separate; border-spacing:0; min-width:1280px;}
    th,td{
      border-bottom:1px solid var(--line);
      padding:10px 10px;
      vertical-align:top;
      writing-mode:horizontal-tb !important;
      word-break:normal !important;
      overflow-wrap:anywhere;
      white-space:normal;
    }
    th{
      position:sticky; top:0; background:var(--panel);
      z-index:2; text-align:left; font-size:13px; color:#374151;
    }
    tr:hover td{background:#fafafa;}
    .cell{
      display:flex; align-items:flex-start; gap:10px;
    }
    .val{flex:1 1 auto; min-width:0;}
    .val.small{color:var(--muted); font-size:12px;}
    .xbtn{
      flex:0 0 auto;
      width:52px; height:52px;  /* BIG */
      border-radius:14px;
      border:2px solid var(--xline);
      background:var(--xbg);
      color:var(--xtext);
      font-weight:900;
      font-size:16px;
      cursor:pointer;
      user-select:none;
    }
    .xbtn:active{transform:scale(.98);}
    .xbtn[aria-pressed="true"]{
      background:#ef4444; color:#fff; border-color:#ef4444;
    }
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;}
    .col-pub{min-width:120px}
    .col-title{min-width:360px}
    .col-kor{min-width:280px}
    .col-sub{min-width:340px}
    .col-isbn{min-width:160px}
    .col-price{min-width:110px}
    .col-cur{min-width:110px}
    .col-date{min-width:140px}
    .col-pages{min-width:110px}
    .notice{
      padding:10px 16px;
      border-top:1px solid var(--line);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .notice .warn{color:#92400e; background:#fffbeb; border:1px solid #fde68a; padding:8px 10px; border-radius:12px; font-weight:800; font-size:12px;}
    @media (max-width: 1100px){
      .row{grid-template-columns:1fr;}
      .side{border-left:none;}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <div class="header">
        <div class="title">27번 도구 – 엑셀 업로드 (셀 X 안정화 v1)</div>
        <div class="desc">
          셀마다 X만 존재 · PASS 없음 · 행 X 없음 · 정렬/재배치 없음 · ANCHOR+HASH로 행 섞임 원천 차단 · 로그 자동 저장(localStorage)<br/>
          지원: CSV/TSV (XLSX 미지원) · 컬럼 하드고정: Publisher, Title, Sub Title, KOR_TITLE, KOR_SUBTITLE, ISBN, Price, Currency, Pub Date, Pages<br/>
          KOR_TITLE은 Title 오른쪽, KOR_SUBTITLE은 Sub Title 오른쪽으로 고정 표시
        </div>
      </div>

      <div class="toolbar">
        <div class="file">
          <b>파일 선택</b>
          <input id="fileInput" type="file" accept=".csv,.tsv,.txt" />
          <button class="btn ok" id="btnUpload">업로드(추가/합치기)</button>
          <button class="btn danger" id="btnResetDb">DB 초기화</button>
          <span class="pill">DB키: <span class="mono" id="dbKeyView"></span></span>
          <span class="pill">LOG키: <span class="mono" id="logKeyView"></span></span>
        </div>
        <div class="stat" id="statLine">
          <span>상태: <b id="stStatus">대기</b></span>
          <span>총 행: <b id="stRows">0</b></span>
          <span>총 셀 X: <b id="stX">0</b></span>
          <span>마지막 파일: <b id="stFile">-</b></span>
        </div>
        <div class="hint">
          • 업로드 후 위치가 움직이지 않도록 ANCHOR = 파일명|row:n 기준으로 고정 렌더합니다.<br/>
          • X는 “그 셀만” X 처리(다른 셀/행 영향 없음) + 즉시 로그에 기록 + localStorage 저장
        </div>
      </div>

      <div class="row">
        <div class="main">
          <div class="tableWrap">
            <table id="tbl">
              <thead><tr id="theadRow"></tr></thead>
              <tbody id="tbody"></tbody>
            </table>
          </div>

          <div class="notice">
            <div class="warn">주의: 이 화면은 “안정화 전용”이라 보기 예쁜 UI보다 “클릭/로그/섞임 차단”을 우선합니다.</div>
          </div>
        </div>

        <div class="side card">
          <div class="sideHead">자동 로그 (셀 X 클릭 시 즉시 누적/저장)</div>
          <div class="sideBody mono" id="logBox"></div>
          <div class="sideFoot">
            <button class="btn" id="btnCopyLog">로그 복사</button>
            <button class="btn danger" id="btnClearLog">로그 초기화</button>
            <button class="btn" id="btnExportDb">DB 내보내기(JSON)</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Fixed keys =====
  const DB_KEY  = "wic_xdb_v27";
  const LOG_KEY = "wic_xlog_v27";
  document.getElementById("dbKeyView").textContent = DB_KEY;
  document.getElementById("logKeyView").textContent = LOG_KEY;

  // ===== Column order MUST match instruction =====
  const COLS = [
    {key:"Publisher",     cls:"col-pub"},
    {key:"Title",         cls:"col-title"},
    {key:"KOR_TITLE",     cls:"col-kor"},       // Title RIGHT
    {key:"Sub Title",     cls:"col-sub"},
    {key:"KOR_SUBTITLE",  cls:"col-kor"},       // Sub Title RIGHT
    {key:"ISBN",          cls:"col-isbn"},
    {key:"Price",         cls:"col-price"},
    {key:"Currency",      cls:"col-cur"},
    {key:"Pub Date",      cls:"col-date"},
    {key:"Pages",         cls:"col-pages"},
  ];

  // ===== In-memory =====
  let db = loadDb();        // { anchors: [anchor...], rowsByAnchor: {anchor: rowObj}, xByAnchorCol: { "anchor|col": true }, fileByAnchor: {} }
  let logLines = loadLog(); // [string...]

  // ===== Render header =====
  const theadRow = document.getElementById("theadRow");
  theadRow.innerHTML = COLS.map(c => `<th class="${c.cls}">${escapeHtml(c.key)}</th>`).join("");

  // ===== UI refs =====
  const fileInput = document.getElementById("fileInput");
  const btnUpload = document.getElementById("btnUpload");
  const btnResetDb = document.getElementById("btnResetDb");
  const btnCopyLog = document.getElementById("btnCopyLog");
  const btnClearLog = document.getElementById("btnClearLog");
  const btnExportDb = document.getElementById("btnExportDb");

  const stStatus = document.getElementById("stStatus");
  const stRows = document.getElementById("stRows");
  const stX = document.getElementById("stX");
  const stFile = document.getElementById("stFile");
  const tbody = document.getElementById("tbody");
  const logBox = document.getElementById("logBox");

  // ===== Init render =====
  renderAll();
  renderLog();

  // ===== Handlers =====
  btnUpload.addEventListener("click", async () => {
    const f = fileInput.files?.[0];
    if (!f) { setStatus("파일 없음"); return; }
    const name = f.name || "unknown";
    if (!/\.(csv|tsv|txt)$/i.test(name)) { setStatus("CSV/TSV만 지원"); return; }

    setStatus("읽는 중...");
    const text = await f.text();
    setStatus("파싱 중...");
    const rows = parseDelimited(text, name);
    // merge by anchor (file|row:n)
    const beforeCount = db.anchors.length;
    const {added, updated} = mergeRows(rows, name);
    saveDb();
    setStatus(`업로드 완료 (추가 ${added}, 갱신 ${updated}, 총 ${db.anchors.length})`);
    stFile.textContent = name;

    appendLog(`[${ts()}] 파일 선택: ${name} (저장X)`);
    appendLog(`[${ts()}] 업로드(추가/합치기): ${name} (추가 ${added}, 갱신 ${updated}, 총 ${db.anchors.length})`);
    renderAll();
    renderLog();
  });

  btnResetDb.addEventListener("click", () => {
    db = { anchors: [], rowsByAnchor: {}, xByAnchorCol: {}, fileByAnchor: {} };
    saveDb();
    setStatus("DB 초기화");
    appendLog(`[${ts()}] DB 초기화`);
    renderAll();
    renderLog();
  });

  btnCopyLog.addEventListener("click", async () => {
    const text = logLines.join("\n");
    await navigator.clipboard.writeText(text);
    setStatus("로그 복사됨");
  });

  btnClearLog.addEventListener("click", () => {
    logLines = [];
    saveLog();
    setStatus("로그 초기화");
    renderLog();
  });

  btnExportDb.addEventListener("click", () => {
    const payload = JSON.stringify(db, null, 2);
    const blob = new Blob([payload], {type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "wic_xdb_v27_export.json";
    a.click();
    URL.revokeObjectURL(a.href);
    setStatus("DB 내보내기 완료");
  });

  // ===== Cell X click (event delegation) =====
  document.addEventListener("click", (e) => {
    const b = e.target.closest(".xbtn");
    if (!b) return;
    const anchor = b.dataset.anchor;
    const col = b.dataset.col;
    const key = `${anchor}|${col}`;
    const row = db.rowsByAnchor[anchor] || {};
    const before = (row[col] ?? "").toString();

    // toggle X
    const nowPressed = !(db.xByAnchorCol[key] === true);
    db.xByAnchorCol[key] = nowPressed;

    // Persist
    saveDb();

    // Log
    const after = nowPressed ? "X" : "(복구)";
    appendLog(`[${ts()}] ${anchor} | ${col} | ${safeInline(before)} → ${after}`);
    saveLog();
    renderLog();

    // Re-render only that row (no shifting)
    refreshRow(anchor);
    updateStats();
  });

  // ===== Core =====
  function mergeRows(parsedRows, fileName){
    let added = 0, updated = 0;
    // parsedRows items: {anchor, rowIndex, data}
    for (const item of parsedRows){
      const anchor = item.anchor;
      const data = normalizeRow(item.data);

      if (!db.rowsByAnchor[anchor]) {
        db.anchors.push(anchor);
        db.rowsByAnchor[anchor] = data;
        db.fileByAnchor[anchor] = fileName;
        added++;
      } else {
        db.rowsByAnchor[anchor] = data;
        db.fileByAnchor[anchor] = fileName;
        updated++;
      }
    }
    // anchor order: stable (first seen order). no sorting.
    return {added, updated};
  }

  function normalizeRow(obj){
    const out = {};
    for (const c of COLS) out[c.key] = (obj[c.key] ?? "").toString();
    return out;
  }

  function renderAll(){
    tbody.innerHTML = "";
    for (const anchor of db.anchors){
      tbody.appendChild(renderRow(anchor));
    }
    updateStats();
  }

  function refreshRow(anchor){
    const tr = tbody.querySelector(`tr[data-anchor="${cssEscape(anchor)}"]`);
    if (!tr) return;
    const fresh = renderRow(anchor);
    tr.replaceWith(fresh);
  }

  function renderRow(anchor){
    const tr = document.createElement("tr");
    tr.dataset.anchor = anchor;

    const row = db.rowsByAnchor[anchor] || {};
    for (const c of COLS){
      const td = document.createElement("td");
      td.className = c.cls;

      const key = `${anchor}|${c.key}`;
      const pressed = db.xByAnchorCol[key] === true;

      // If X pressed, show X; else show original value
      const raw = (row[c.key] ?? "").toString().trim();
      const displayVal = pressed ? "X" : raw;

      td.innerHTML = `
        <div class="cell">
          <div class="val ${displayVal ? "" : "small"}">
            ${displayVal ? escapeHtml(displayVal) : '<span class="val small">(빈값)</span>'}
          </div>
          <button class="xbtn" aria-pressed="${pressed ? "true" : "false"}"
            title="${pressed ? "X 해제" : "이 셀을 X 처리"}"
            data-anchor="${escapeHtmlAttr(anchor)}" data-col="${escapeHtmlAttr(c.key)}">X</button>
        </div>
      `;
      tr.appendChild(td);
    }
    return tr;
  }

  function updateStats(){
    stRows.textContent = String(db.anchors.length);
    const xCount = Object.values(db.xByAnchorCol).filter(v => v === true).length;
    stX.textContent = String(xCount);
  }

  function setStatus(s){ stStatus.textContent = s; }

  // ===== Log =====
  function appendLog(line){
    logLines.push(line);
    // keep last 600 lines to avoid memory bloat
    if (logLines.length > 600) logLines = logLines.slice(-600);
    saveLog();
  }
  function renderLog(){
    if (logLines.length === 0){
      logBox.textContent = "로그 형식: [YYYY-MM-DD HH:MM:SS] 파일명|row:n | COL | before → after";
      return;
    }
    logBox.textContent = logLines.join("\n");
  }

  // ===== Storage =====
  function loadDb(){
    try{
      const s = localStorage.getItem(DB_KEY);
      if(!s) return { anchors: [], rowsByAnchor: {}, xByAnchorCol: {}, fileByAnchor: {} };
      const o = JSON.parse(s);
      // minimal validation
      if(!o || !Array.isArray(o.anchors) || !o.rowsByAnchor) throw new Error("bad db");
      if(!o.xByAnchorCol) o.xByAnchorCol = {};
      if(!o.fileByAnchor) o.fileByAnchor = {};
      return o;
    }catch{
      return { anchors: [], rowsByAnchor: {}, xByAnchorCol: {}, fileByAnchor: {} };
    }
  }
  function saveDb(){
    localStorage.setItem(DB_KEY, JSON.stringify(db));
  }
  function loadLog(){
    try{
      const s = localStorage.getItem(LOG_KEY);
      if(!s) return [];
      const o = JSON.parse(s);
      return Array.isArray(o) ? o : [];
    }catch{
      return [];
    }
  }
  function saveLog(){
    localStorage.setItem(LOG_KEY, JSON.stringify(logLines));
  }

  // ===== Parser: CSV/TSV =====
  // anchor = fileName|row:n (n starts from 2 when header exists)
  function parseDelimited(text, fileName){
    const delimiter = guessDelimiter(text, fileName);
    const lines = splitLines(text);
    if (lines.length === 0) return [];

    // detect header
    const first = parseLine(lines[0], delimiter);
    const headerMap = buildHeaderMap(first);

    const hasHeader = headerMap.score >= 2; // needs at least 2 matching fixed columns
    const startIdx = hasHeader ? 1 : 0;

    const out = [];
    for (let i = startIdx; i < lines.length; i++){
      const arr = parseLine(lines[i], delimiter);
      if (arr.every(x => !x || !x.trim())) continue;

      const rowObj = {};
      if (hasHeader){
        for (const c of COLS){
          const idx = headerMap.idxByKey[c.key];
          rowObj[c.key] = idx >= 0 ? (arr[idx] ?? "") : "";
        }
      } else {
        // No header: fill by COLS order
        for (let k = 0; k < COLS.length; k++){
          rowObj[COLS[k].key] = (arr[k] ?? "");
        }
      }

      const rowNumber = hasHeader ? (i + 1) : (i + 1); // 1-based in file
      const anchor = `${fileName}|row:${rowNumber}`;
      out.push({anchor, rowIndex: rowNumber, data: rowObj});
    }
    return out;
  }

  function guessDelimiter(text, fileName){
    if (/\.tsv$/i.test(fileName)) return "\t";
    const sample = text.slice(0, 5000);
    const c = (sample.match(/,/g) || []).length;
    const t = (sample.match(/\t/g) || []).length;
    return (t > c) ? "\t" : ",";
  }

  function splitLines(text){
    return text.replace(/\r\n/g,"\n").replace(/\r/g,"\n").split("\n").filter(l => l.length > 0);
  }

  function parseLine(line, delimiter){
    // simple CSV with quotes
    const res = [];
    let cur = "";
    let q = false;
    for (let i=0;i<line.length;i++){
      const ch = line[i];
      if (ch === '"'){
        if (q && line[i+1] === '"'){ cur += '"'; i++; }
        else { q = !q; }
      } else if (!q && ch === delimiter){
        res.push(cur.trim());
        cur = "";
      } else {
        cur += ch;
      }
    }
    res.push(cur.trim());
    return res;
  }

  function buildHeaderMap(headerArr){
    const norm = headerArr.map(h => normalizeHeader(h));
    const idxByKey = {};
    let score = 0;
    for (const c of COLS){
      const want = normalizeHeader(c.key);
      const idx = norm.indexOf(want);
      idxByKey[c.key] = idx;
      if (idx >= 0) score++;
    }
    return {idxByKey, score};
  }

  function normalizeHeader(s){
    return (s || "")
      .toString()
      .trim()
      .toLowerCase()
      .replace(/\s+/g," ")
      .replace(/_/g," ");
  }

  // ===== Utils =====
  function ts(){
    const d = new Date();
    const pad = (n)=> String(n).padStart(2,"0");
    const y = d.getFullYear();
    const m = pad(d.getMonth()+1);
    const day = pad(d.getDate());
    const hh = pad(d.getHours());
    const mm = pad(d.getMinutes());
    const ss = pad(d.getSeconds());
    return `${y}-${m}-${day} ${hh}:${mm}:${ss}`;
  }

  function safeInline(s){
    return (s || "").toString().replace(/\s+/g," ").slice(0, 120);
  }

  function escapeHtml(s){
    return (s ?? "").toString()
      .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
      .replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }
  function escapeHtmlAttr(s){ return escapeHtml(s).replaceAll("\n"," "); }
  function cssEscape(s){
    // minimal escape for attribute selector
    return (s ?? "").toString().replaceAll('"','\\"');
  }
})();
</script>
</body>
</html>
